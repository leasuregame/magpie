1、CCTouchDispatcher.cpp
吞没点击后，仍然往下发送ccTouchesEnd & ccTouchesCancelled事件
if (uStandardHandlersCount > 0)
    {
        CCStandardTouchHandler *pHandler = NULL;
        CCObject* pObj = NULL;
        CCARRAY_FOREACH(m_pStandardHandlers, pObj)
        {
            pHandler = (CCStandardTouchHandler*)(pObj);
            
            if (! pHandler)
            {
                break;
            }
            
            switch (sHelper.m_type)
            {
                case CCTOUCHBEGAN:
                    if(pMutableTouches->count() > 0) {
                        pHandler->getDelegate()->ccTouchesBegan(pMutableTouches, pEvent);
                    }
                    break;
                case CCTOUCHMOVED:
                    if(pMutableTouches->count() > 0) {
                        pHandler->getDelegate()->ccTouchesMoved(pMutableTouches, pEvent);
                    }
                    break;
                case CCTOUCHENDED:
                    pHandler->getDelegate()->ccTouchesEnded(pMutableTouches, pEvent);
                    break;
                case CCTOUCHCANCELLED:
                    pHandler->getDelegate()->ccTouchesCancelled(pMutableTouches, pEvent);
                    break;
            }
        }
    }

2、jsb_cocos2d.js
添加Menu继承支持
cc.Menu.extend = cc.Class.extend;

3、CCMenu.cpp
点击事件发送到js
bool CCMenu::ccTouchBegan(CCTouch* touch, CCEvent* event)
{
    if (kScriptTypeNone != m_eScriptType)
    {
        CCLOG("js ccTouchBegan");
        CCScriptEngineManager::sharedManager()->getScriptEngine()->executeLayerTouchEvent(this, CCTOUCHBEGAN, touch);
    }
    
    CC_UNUSED_PARAM(event);
    if (m_eState != kCCMenuStateWaiting || ! m_bVisible || !m_bEnabled)
    {
        return false;
    }

    for (CCNode *c = this->m_pParent; c != NULL; c = c->getParent())
    {
        if (c->isVisible() == false)
        {
            return false;
        }
    }

    m_pSelectedItem = this->itemForTouch(touch);
    if (m_pSelectedItem)
    {
        m_eState = kCCMenuStateTrackingTouch;
        m_pSelectedItem->selected();
        return true;
    }
    return false;
}

void CCMenu::ccTouchEnded(CCTouch *touch, CCEvent* event)
{
    bool isScroll = false;
    
    if (kScriptTypeNone != m_eScriptType)
    {
        CCLOG("js ccTouchEnded");
        isScroll = (CCScriptEngineManager::sharedManager()->getScriptEngine()->executeLayerTouchEvent(this, CCTOUCHENDED, touch) == 1);
    }
    
    if(isScroll)
    {
        CCLOG("isScroll run ccTouchCancelled");
        this->ccTouchCancelled(touch, event);
        return;
    }
    
    CC_UNUSED_PARAM(touch);
    CC_UNUSED_PARAM(event);
    CCAssert(m_eState == kCCMenuStateTrackingTouch, "[Menu ccTouchEnded] -- invalid state");
    if (m_pSelectedItem)
    {
        m_pSelectedItem->unselected();
        m_pSelectedItem->activate();
    }
    m_eState = kCCMenuStateWaiting;
}

void CCMenu::ccTouchCancelled(CCTouch *touch, CCEvent* event)
{
    CC_UNUSED_PARAM(touch);
    CC_UNUSED_PARAM(event);
    CCAssert(m_eState == kCCMenuStateTrackingTouch, "[Menu ccTouchCancelled] -- invalid state");
    if (m_pSelectedItem)
    {
        m_pSelectedItem->unselected();
    }
    m_eState = kCCMenuStateWaiting;
}

void CCMenu::ccTouchMoved(CCTouch* touch, CCEvent* event)
{
    if (kScriptTypeNone != m_eScriptType)
    {
        CCLOG("js ccTouchMoved");
        CCScriptEngineManager::sharedManager()->getScriptEngine()->executeLayerTouchEvent(this, CCTOUCHMOVED, touch);
    }
    
    CC_UNUSED_PARAM(event);
    CCAssert(m_eState == kCCMenuStateTrackingTouch, "[Menu ccTouchMoved] -- invalid state");
    CCMenuItem *currentItem = this->itemForTouch(touch);
    if (currentItem != m_pSelectedItem) 
    {
        if (m_pSelectedItem)
        {
            m_pSelectedItem->unselected();
        }
        m_pSelectedItem = currentItem;
        if (m_pSelectedItem)
        {
            m_pSelectedItem->selected();
        }
    }
}

4、CCBAnimationManager.h  CCBAnimationManager.cpp  jsb_cocos2dx_extension_auto.cpp
float getSequenceDuration(const std::string &name);

float CCBAnimationManager::getSequenceDuration(const std::string &name)
{
    int id = getSequenceId(name.c_str());
    
    if(id == -1)
    {
        CCLOGERROR("can not found sequence %s",name.c_str());
        return 0;
    }
    
    CCBSequence* s = getSequence(id);
    
    if(s == NULL){
        
        CCLOGERROR("sequence %s is NULL",name.c_str());
        return 0;
    }
    
    return s->getDuration();
}

JSBool js_cocos2dx_extension_CCBAnimationManager_getSequenceDuration(JSContext *cx, uint32_t argc, jsval *vp)
{
	jsval *argv = JS_ARGV(cx, vp);
	JSBool ok = JS_TRUE;
	JSObject *obj = JS_THIS_OBJECT(cx, vp);
	js_proxy_t *proxy = jsb_get_js_proxy(obj);
	cocos2d::extension::CCBAnimationManager* cobj = (cocos2d::extension::CCBAnimationManager *)(proxy ? proxy->ptr : NULL);
	JSB_PRECONDITION2( cobj, cx, JS_FALSE, "Invalid Native Object");
	if (argc == 1) {
		std::string arg0;
		ok &= jsval_to_std_string(cx, argv[0], &arg0);
		JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
		float ret = cobj->getSequenceDuration(arg0);
		jsval jsret;
        jsret = DOUBLE_TO_JSVAL(ret);
		JS_SET_RVAL(cx, vp, jsret);
		return JS_TRUE;
	}
    
	JS_ReportError(cx, "wrong number of arguments: %d, was expecting %d", argc, 1);
	return JS_FALSE;
}

5、CCControl.cpp
bool CCControl::init()
{
    if (CCLayer::init())
    {
        //this->setTouchEnabled(true);
        //m_bIsTouchEnabled=true;
        // Initialise instance variables
        m_eState=CCControlStateNormal;
        setEnabled(true);
        setSelected(false);
        setHighlighted(false);

        // Set the touch dispatcher priority by default to 1
        // 修改优先级与按钮一样
        this->setTouchPriority(-128);
        // Initialise the tables
        m_pDispatchTable = new CCDictionary(); 
        // Initialise the mapHandleOfControlEvents
        m_mapHandleOfControlEvent.clear();
        
        return true;
    }
    else
    {
        return false;
    }
}

6、WebSocket.cpp
/ 修改缓冲区大小
_wsProtocols[i].rx_buffer_size = 1024 * 200;  // 200k
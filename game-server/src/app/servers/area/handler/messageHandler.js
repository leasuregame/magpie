// Generated by CoffeeScript 1.6.2
var ADD_FRIEND_MESSAGE, DELETE_FRIEND_MESSAGE, Handler, MAX_POWER_VALUE, SYSTEM, achieve, async, changeGroupNameAndSort, configData, dao, isFinalStatus, logger, mergeMessages, playerManager, resData, sendMessage, table, updateGiveCount, updateReceiveCount, utility, _,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

dao = require('pomelo').app.get('dao');

playerManager = require('pomelo').app.get('playerManager');

configData = require('../../../../config/data');

logger = require('pomelo-logger').getLogger(__filename);

async = require('async');

achieve = require('../../../domain/achievement');

_ = require('underscore');

utility = require('../../../common/utility');

table = require('../../../manager/table');

resData = table.getTableItem('resource_limit', 1);

MAX_POWER_VALUE = resData.power_value;

SYSTEM = -1;

ADD_FRIEND_MESSAGE = 1;

DELETE_FRIEND_MESSAGE = 2;

module.exports = function(app) {
  return new Handler(app);
};

Handler = function(app) {
  this.app = app;
};

Handler.prototype.messageList = function(msg, session, next) {
  var playerId;

  playerId = session.get('playerId');
  return async.parallel([
    function(cb) {
      return dao.message.fetchMany({
        limit: 20,
        orderby: ' createTime DESC ',
        where: {
          sender: -1,
          receiver: -1,
          type: configData.message.MESSAGETYPE.SYSTEM,
          msgId: null
        }
      }, cb);
    }, function(cb) {
      return dao.message.fetchMany({
        where: {
          receiver: playerId,
          type: configData.message.MESSAGETYPE.BATTLENOTICE
        },
        limit: 20,
        orderby: ' createTime DESC '
      }, cb);
    }, function(cb) {
      return dao.message.fetchMany({
        where: " receiver = " + playerId + " and           type in (" + configData.message.MESSAGETYPE.SYSTEM + ", " + configData.message.MESSAGETYPE.ADDFRIEND + ", " + configData.message.MESSAGETYPE.MESSAGE + ") and           status <> " + configData.message.MESSAGESTATUS.ASKING + " ",
        orderby: ' createTime DESC '
      }, cb);
    }, function(cb) {
      return dao.message.fetchMany({
        where: {
          receiver: playerId,
          type: configData.message.MESSAGETYPE.ADDFRIEND,
          status: configData.message.MESSAGESTATUS.ASKING
        },
        limit: 20,
        orderby: ' createTime DESC '
      }, cb);
    }
  ], function(err, results) {
    var blMessages, friendMessages, messages, msgs, systemMessages, unhandledMessage;

    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    systemMessages = results[0];
    blMessages = results[1];
    friendMessages = results[2];
    unhandledMessage = results[3];
    messages = mergeMessages(friendMessages, systemMessages, blMessages, unhandledMessage);
    messages = messages.map(function(m) {
      if (m.type === configData.message.MESSAGETYPE.MESSAGE) {
        return typeof m.toLeaveMessage === "function" ? m.toLeaveMessage() : void 0;
      } else {
        return typeof m.toJson === "function" ? m.toJson() : void 0;
      }
    });
    messages = _.groupBy(messages, function(item) {
      return item.type;
    });
    msgs = changeGroupNameAndSort(messages);
    return next(null, {
      code: 200,
      msg: msgs
    });
  });
};

Handler.prototype.sysMsg = function(msg, session, next) {
  var content, options, receiver,
    _this = this;

  content = msg.content;
  options = msg.options || {};
  receiver = msg.playerId || SYSTEM;
  return async.waterfall([
    function(cb) {
      if (receiver !== SYSTEM) {
        return playerManager.getPlayerInfo({
          pid: receiver
        }, function(err, res) {
          if (err) {
            return cb({
              code: 501,
              msg: '找不到指定玩家'
            });
          } else {
            return cb();
          }
        });
      } else {
        return cb();
      }
    }, function(cb) {
      return dao.message.create({
        data: {
          options: options,
          sender: SYSTEM,
          receiver: receiver,
          content: content,
          type: configData.message.MESSAGETYPE.SYSTEM,
          status: configData.message.MESSAGESTATUS.UNHANDLED
        }
      }, cb);
    }
  ], function(err, res) {
    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    return sendMessage(_this.app, msg.playerId, {
      route: 'onMessage',
      msg: res.toJson()
    }, '邮件发送成功', next);
  });
};

Handler.prototype.handleSysMsg = function(msg, session, next) {
  var incValues, msgId, player, playerId;

  playerId = session.get('playerId');
  msgId = msg.msgId;
  player = null;
  incValues = function(obj, data) {
    var k, _i, _len, _ref;

    _ref = _.keys(data);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      if (obj.hasField(k)) {
        obj.increase(k, data[k]);
      }
    }
    if (_.has(data, 'powerValue')) {
      obj.addPower(data.powerValue);
    }
    if (_.has(data, 'spirit')) {
      return obj.incSpirit(data.spirit);
    }
  };
  return async.waterfall([
    function(cb) {
      return dao.message.fetchOne({
        where: {
          id: msgId
        }
      }, function(err, message) {
        if (err) {
          return cb({
            code: err.code || 500,
            msg: err.msg || err
          });
        } else if (message.type !== configData.message.MESSAGETYPE.SYSTEM) {
          return cb({
            code: 501,
            msg: '消息类型不匹配'
          });
        } else if (message.status === configData.message.MESSAGESTATUS.HANDLED) {
          return cb({
            code: 501,
            msg: '该邮件已领取过'
          });
        } else {
          return cb(null, message);
        }
      });
    }, function(message, cb) {
      return dao.message.fetchOne({
        where: {
          msgId: message.id,
          receiver: playerId
        }
      }, function(err, res) {
        if (res !== null) {
          return cb({
            code: 501,
            msg: '该邮件已领取过'
          });
        } else {
          return cb(null, message);
        }
      });
    }, function(message, cb) {
      return playerManager.getPlayerInfo({
        pid: playerId
      }, function(err, res) {
        if (err) {
          return cb({
            code: err.code || 500,
            msg: err.msg || err
          });
        }
        player = res;
        return cb(null, message);
      });
    }, function(message, cb) {
      var data, k, _i, _len, _ref;

      if (message.receiver === playerId) {
        return dao.message.update({
          data: {
            status: configData.message.MESSAGESTATUS.HANDLED
          },
          where: {
            id: msgId
          }
        }, function(err, res) {
          return cb(err, message.options);
        });
      } else {
        data = {};
        _ref = _.keys(message.attributes);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          if (k !== 'id') {
            data[k] = message[k];
          }
        }
        data.status = configData.message.MESSAGESTATUS.HANDLED;
        data.msgId = message.id;
        data.receiver = playerId;
        return dao.message.create({
          data: data
        }, function(err, res) {
          return cb(err, res.options);
        });
      }
    }, function(options, cb) {
      incValues(player, options);
      player.save();
      return cb(null, options);
    }
  ], function(err, data) {
    if (err) {
      next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    return next(null, {
      code: 200,
      msg: data
    });
  });
};

Handler.prototype.leaveMessage = function(msg, session, next) {
  var content, friendId, playerId, playerName,
    _this = this;

  playerId = session.get('playerId');
  playerName = session.get('playerName');
  friendId = msg.friendId;
  content = msg.content;
  if (playerId === friendId) {
    return next(null, {
      code: 501,
      msg: '不能给自己留言'
    });
  }
  return dao.message.create({
    data: {
      type: configData.message.MESSAGETYPE.MESSAGE,
      sender: playerId,
      options: {
        playerName: playerName
      },
      receiver: friendId,
      content: content.slice(0, 50),
      status: configData.message.MESSAGESTATUS.UNHANDLED
    }
  }, function(err, res) {
    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    return sendMessage(_this.app, friendId, {
      route: 'onMessage',
      msg: res.toLeaveMessage()
    }, null, next);
  });
};

Handler.prototype.setAsRead = function(msg, session, next) {
  var msgId;

  msgId = msg.msgId;
  return dao.message.update({
    where: {
      id: msgId
    },
    data: {
      status: configData.message.MESSAGESTATUS.HANDLED
    }
  }, function(err, res) {
    if (err) {
      logger.error('can not update message status with id', msgId);
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    return next(null, {
      code: 200
    });
  });
};

Handler.prototype.readMessage = function(msg, session, next) {
  var msgId, playerId;

  playerId = session.get('playerId');
  msgId = msg.msgId;
  return dao.message.fetchOne({
    where: {
      id: msgId
    }
  }, function(err, res) {
    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    dao.message.update({
      where: {
        id: msgId
      },
      data: {
        status: configData.message.MESSAGESTATUS.HANDLED
      }
    }, function(err, updated) {
      if (err) {
        return logger.error('can not update message status with id', msgId);
      }
    });
    return next(null, {
      code: 200,
      msg: res.content
    });
  });
};

Handler.prototype.deleteFriend = function(msg, session, next) {
  var friendId, playerId,
    _this = this;

  playerId = session.get('playerId');
  friendId = msg.friendId;
  return async.parallel([
    function(cb) {
      return dao.friend.deleteFriend({
        playerId: playerId,
        friendId: friendId
      }, cb);
    }, function(cb) {
      var condiction, type;

      type = configData.message.MESSAGETYPE;
      condiction = " (sender=" + playerId + " and receiver=" + friendId + " and type in (" + type.MESSAGE + ", " + type.ADDFRIEND + ", " + type.BLESS + "))         or (sender=" + friendId + " and receiver=" + playerId + " and type in (" + type.MESSAGE + ", " + type.ADDFRIEND + ", " + type.BLESS + ")) ";
      return dao.message["delete"]({
        where: condiction
      }, cb);
    }, function(cb) {
      return playerManager.getPlayerInfo({
        pid: playerId
      }, cb);
    }
  ], function(err, results) {
    var player;

    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    player = results[2];
    player.delFriend(friendId);
    playerManager.delFriendIfOnline(friendId, playerId);
    next(null, {
      code: 200
    });
    return sendMessage(_this.app, friendId, {
      route: 'onFriendAction',
      msg: {
        type: DELETE_FRIEND_MESSAGE,
        friend: {
          id: playerId
        }
      }
    });
  });
};

Handler.prototype.addFriend = function(msg, session, next) {
  var friend, friendName, playerId, playerName,
    _this = this;

  playerId = session.get('playerId');
  playerName = session.get('playerName');
  friendName = msg.friendName;
  if (playerName === friendName) {
    return next(null, {
      code: 501,
      msg: '不能添加自己为好友'
    });
  }
  friend = null;
  return async.waterfall([
    function(cb) {
      return playerManager.getPlayerInfo({
        pid: playerId
      }, function(err, ply) {
        if (err) {
          return cb(err);
        }
        if (_.filter(ply.friends, function(f) {
          return f.name === friendName;
        }).length > 0) {
          return cb({
            code: 501,
            msg: '对方已经是你的好友'
          });
        } else if (ply.friends.length >= ply.friendsCount) {
          return cb({
            code: 501,
            msg: '您的好友已达上限'
          });
        } else {
          return cb();
        }
      });
    }, function(cb) {
      return playerManager.getPlayer({
        name: friendName
      }, cb);
    }, function(res, cb) {
      friend = res;
      return dao.friend.getFriends(friend.id, function(err, senderFriends) {
        if (err) {
          return next(null, {
            code: err.code || 500,
            msg: err.msg || err
          });
        } else if (senderFriends.length >= friend.friendsCount) {
          return cb({
            code: 501,
            msg: '对方好友已达上限'
          });
        } else {
          return dao.message.fetchOne({
            where: {
              type: configData.message.MESSAGETYPE.ADDFRIEND,
              sender: playerId,
              receiver: friend.id,
              status: configData.message.MESSAGESTATUS.ASKING
            }
          }, function(err, res) {
            if (!err && !!res) {
              return cb(null, true);
            } else {
              return cb(null, false);
            }
          });
        }
      });
    }, function(exist, cb) {
      if (!exist) {
        return dao.message.create({
          data: {
            type: configData.message.MESSAGETYPE.ADDFRIEND,
            sender: playerId,
            receiver: friend.id,
            content: "" + playerName + "发来请求",
            status: configData.message.MESSAGESTATUS.ASKING
          }
        }, cb);
      } else {
        return cb({
          code: 501,
          msg: '不能重复发送请求'
        });
      }
    }
  ], function(err, msg) {
    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    return sendMessage(_this.app, friend.id, {
      route: 'onMessage',
      msg: msg.toJson()
    }, null, next);
  });
};

Handler.prototype.accept = function(msg, session, next) {
  var friendExist, message, msgId, player, playerId, playerName,
    _this = this;

  playerId = session.get('playerId');
  playerName = session.get('playerName');
  msgId = msg.msgId;
  message = null;
  player = null;
  friendExist = false;
  return async.waterfall([
    function(cb) {
      return dao.message.fetchOne({
        where: {
          id: msgId
        }
      }, cb);
    }, function(res, cb) {
      message = res;
      if (message.receiver !== playerId) {
        return cb({
          code: 501,
          msg: '你没有权限处理此消息'
        });
      }
      if (message.type !== configData.message.MESSAGETYPE.ADDFRIEND) {
        return cb({
          code: 501,
          msg: '消息类型不匹配'
        });
      }
      if (isFinalStatus(message.status)) {
        return cb({
          code: 501,
          msg: '已处理'
        });
      }
      return cb();
    }, function(cb) {
      return playerManager.getPlayerInfo({
        pid: playerId
      }, cb);
    }, function(res, cb) {
      player = res;
      if (player.friends.length >= player.friendsCount) {
        return cb({
          code: 501,
          msg: '您的好友已达上限'
        });
      } else if ((player.friends.filter(function(f) {
        return f.id === message.sender;
      })).length > 0) {
        friendExist = true;
        return cb();
      } else {
        return cb();
      }
    }, function(cb) {
      return playerManager.getPlayerInfo({
        pid: message.sender
      }, cb);
    }, function(res, cb) {
      return dao.friend.getFriends(res.id, function(err, senderFriends) {
        if (err) {
          return cb({
            code: err.code || 500,
            msg: err.msg || err
          });
        } else if ((senderFriends.filter(function(f) {
          return f.id === playerId;
        })).length > 0) {
          friendExist = true;
          return cb(null, null);
        } else if (senderFriends.length >= res.friendsCount) {
          return dao.message.update({
            where: {
              id: msgId
            },
            data: {
              status: configData.message.MESSAGESTATUS.REJECT
            }
          }, function(err, res) {
            if (err) {
              return cb(err);
            } else {
              return cb({
                code: 501,
                msg: '对方好友已达上限'
              });
            }
          });
        } else {
          return dao.friend.create({
            data: {
              playerId: message.sender,
              friendId: message.receiver
            }
          }, cb);
        }
      });
    }, function(friend, cb) {
      message.status = configData.message.MESSAGESTATUS.ACCEPT;
      return dao.message.update({
        where: {
          id: msgId
        },
        data: {
          status: configData.message.MESSAGESTATUS.ACCEPT
        }
      }, cb);
    }, function(updated, cb) {
      return dao.player.fetchOne({
        where: {
          id: message.sender
        },
        sync: true
      }, cb);
    }
  ], function(err, sender) {
    var myInfo, newFriend;

    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    if (friendExist) {
      return next(null, {
        code: 501,
        msg: '对方已经是你的好友'
      });
    }
    newFriend = {
      id: sender.id,
      name: sender.name,
      lv: sender.lv,
      ability: sender.ability
    };
    myInfo = {
      id: playerId,
      name: playerName,
      lv: player.lv,
      ability: player.ability
    };
    next(null, {
      code: 200,
      msg: newFriend
    });
    player.addFriend(newFriend);
    playerManager.addFriendIfOnline(sender.id, myInfo);
    achieve.friends(player);
    achieve.friends(sender);
    return sendMessage(_this.app, message.sender, {
      route: 'onFriendAction',
      msg: {
        type: ADD_FRIEND_MESSAGE,
        friend: myInfo
      }
    });
  });
};

Handler.prototype.reject = function(msg, session, next) {
  var msgId, playerId, playerName,
    _this = this;

  playerId = session.get('playerId');
  playerName = session.get('playerName');
  msgId = msg.msgId;
  return async.waterfall([
    function(cb) {
      return dao.message.fetchOne({
        where: {
          id: msgId
        }
      }, cb);
    }, function(message, cb) {
      if (message.receiver !== playerId) {
        return cb({
          code: 501,
          msg: '你没有权限处理此消息'
        });
      }
      if (message.type !== configData.message.MESSAGETYPE.ADDFRIEND) {
        return cb({
          code: 501,
          msg: '消息类型不匹配'
        });
      }
      if (isFinalStatus(message.status)) {
        return cb({
          code: 200,
          msg: '已处理'
        });
      }
      return dao.message.update({
        where: {
          id: msgId
        },
        data: {
          status: configData.message.MESSAGESTATUS.REJECT
        }
      }, cb);
    }
  ], function(err, res) {
    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    return next(null, {
      code: 200
    });
  });
};

Handler.prototype.giveBless = function(msg, session, next) {
  var ENERGY, friendId, player, playerId, playerName,
    _this = this;

  playerId = session.get('playerId');
  playerName = session.get('playerName');
  friendId = msg.friendId;
  if (friendId === playerId) {
    return next(null, {
      code: 501,
      msg: '不能给自己送祝福'
    });
  }
  ENERGY = 10;
  player = null;
  return async.waterfall([
    function(cb) {
      return playerManager.getPlayerInfo({
        pid: playerId
      }, cb);
    }, function(res, cb) {
      player = res;
      if (player.dailyGift.gaveBless.count <= 0) {
        return cb({
          code: 501,
          msg: '今日你送出祝福的次数已经达到上限'
        });
      }
      if (_.contains(player.dailyGift.gaveBless.receivers, friendId)) {
        return cb({
          code: 501,
          msg: '一天只能给同一位好友送出一次祝福哦'
        });
      }
      return cb();
    }, function(cb) {
      return dao.message.create({
        data: {
          type: configData.message.MESSAGETYPE.BLESS,
          sender: playerId,
          receiver: friendId,
          options: {
            energy: ENERGY
          },
          content: "" + playerName + "为你送来了祝福，你获得了5点的活力值",
          status: configData.message.MESSAGESTATUS.UNHANDLED
        }
      }, cb);
    }
  ], function(err, res) {
    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    player.dailyGift.gaveBless.count--;
    player.dailyGift.gaveBless.receivers.push(friendId);
    player.updateGift('gaveBless', player.dailyGift.gaveBless);
    player.increase('energy', ENERGY);
    player.giveBlessOnce();
    player.save();
    updateGiveCount(player, friendId);
    return sendMessage(_this.app, friendId, {
      route: 'onBless',
      msg: {
        id: res.id,
        sender: res.sender
      }
    }, {
      energy: ENERGY
    }, next);
  });
};

Handler.prototype.receiveBless = function(msg, session, next) {
  var message, msgId, player, playerId;

  playerId = session.get('playerId');
  msgId = msg.msgId;
  message = null;
  player = null;
  return async.waterfall([
    function(cb) {
      return playerManager.getPlayerInfo({
        pid: playerId
      }, cb);
    }, function(ply, cb) {
      player = ply;
      if (player.dailyGift.receivedBless.count <= 0) {
        return cb({
          code: 501,
          msg: '今日可领祝福次数已用完'
        });
      }
      return dao.message.fetchOne({
        where: {
          id: msgId
        }
      }, cb);
    }, function(res, cb) {
      message = res;
      if (message.receiver !== playerId) {
        return cb({
          code: 501,
          msg: '你没有权限处理此消息'
        });
      }
      if (message.type !== configData.message.MESSAGETYPE.BLESS) {
        return cb({
          code: 501,
          msg: '消息类型不匹配'
        });
      }
      if (isFinalStatus(message.status)) {
        return cb({
          code: 200,
          msg: '已处理'
        });
      }
      return cb();
    }, function(cb) {
      player.dailyGift.receivedBless.count--;
      player.dailyGift.receivedBless.givers.push(playerId);
      player.updateGift('receivedBless', player.dailyGift.receivedBless);
      player.receiveBlessOnce();
      player.increase('energy', message.options.energy);
      player.save();
      updateReceiveCount(player, message.sender);
      return cb();
    }, function(cb) {
      return dao.message.update({
        where: {
          id: msgId
        },
        data: {
          status: configData.message.MESSAGESTATUS.HANDLED
        }
      }, cb);
    }
  ], function(err, res) {
    if (err) {
      return next(null, {
        code: err.code || 500,
        msg: err.msg || err
      });
    }
    return next(null, {
      code: 200,
      msg: {
        energy: message.options.energy
      }
    });
  });
};

updateGiveCount = function(player, friendId) {
  return dao.friend.updateGiveCount(player.id, friendId, function(err, res) {
    var _ref;

    if (err || !res) {
      return logger.error(err);
    } else {
      return (_ref = player.friends) != null ? _ref.forEach(function(f) {
        if (f.id === friendId) {
          return f.giveCount += 1;
        }
      }) : void 0;
    }
  });
};

updateReceiveCount = function(player, friendId) {
  return dao.friend.updateReceiveCount(player.id, friendId, function(err, res) {
    var _ref;

    if (err || !res) {
      return logger.error(err);
    } else {
      return (_ref = player.friends) != null ? _ref.forEach(function(f) {
        if (f.id === friendId) {
          return f.receiveCount += 1;
        }
      }) : void 0;
    }
  });
};

isFinalStatus = function(status) {
  return _.contains(configData.message.FINALSTATUS, status);
};

mergeMessages = function(myMessages, systemMessages, blMessages, unhandledMessage) {
  var mySystems;

  mySystems = myMessages.filter(function(m) {
    return m.sender === -1;
  });
  mySystems = mySystems.map(function(m) {
    return m.msgId;
  });
  systemMessages.forEach(function(m) {
    var _ref;

    if (_ref = m.id, __indexOf.call(mySystems, _ref) < 0) {
      return myMessages.push(m);
    }
  });
  blMessages.concat(unhandledMessage).forEach(function(m) {
    return myMessages.push(m);
  });
  return myMessages;
};

changeGroupNameAndSort = function(messages) {
  var copyItems, i, items, j, k, n, name, newItems, results, v, _i, _len, _res;

  results = {};
  for (k in messages) {
    v = messages[k];
    if (configData.message.TYPE_MAP[k] == null) {
      continue;
    }
    name = configData.message.TYPE_MAP[k];
    if (typeof results[name] === 'undefined') {
      results[name] = v;
    } else {
      results[name] = results[name].concat(v);
    }
  }
  for (n in results) {
    items = results[n];
    items.sort(function(x, y) {
      return y.createTime - x.createTime;
    });
    if (n === 'system') {
      items.sort(function(x, y) {
        return x.status - y.status;
      });
    } else if (n === 'friend') {
      copyItems = _.clone(items);
      newItems = [];
      for (j = _i = 0, _len = items.length; _i < _len; j = ++_i) {
        i = items[j];
        if ((i != null) && i.status === configData.message.MESSAGESTATUS.ASKING) {
          _res = copyItems.splice(j, 1);
          newItems = newItems.concat(_res);
        }
      }
      newItems = newItems.concat(copyItems);
      items = newItems;
    }
    results[n] = items.slice(0, 20);
  }
  return results;
};

sendMessage = function(app, target, msg, data, next) {
  var callback;

  callback = function(err, res) {
    var code;

    if (err) {
      code = 500;
    } else {
      code = 200;
    }
    if (next != null) {
      return next(null, {
        code: code,
        msg: data ? data : void 0
      });
    }
  };
  if (target != null) {
    return app.get('messageService').pushByPid(target, msg, callback);
  } else {
    return app.get('messageService').pushMessage(msg, callback);
  }
};

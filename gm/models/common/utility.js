// Generated by CoffeeScript 1.6.3
var Utility, fs, _;

fs = require('fs');

_ = require('underscore');

Utility = {
  hitRate: function(rate) {
    var rd;
    rate = parseInt(rate);
    if (isNaN(rate) || rate < 0 && rate > 100) {
      throw new Error("Invilid argument: can't pass " + rate + " to int");
    }
    rd = _.random(0, 100);
    if (rd <= rate) {
      return true;
    } else {
      return false;
    }
  },
  /*
  get random value from the given values
  @param {array} values, the given values for get the random one from them
  @param {array} rates, the option parameter, if given, will return the value for the rates
  */

  randomValue: function(values, rates, maxVal) {
    var i, r, rd, _i, _j, _len, _len1, _r, _rates;
    if (maxVal == null) {
      maxVal = 100;
    }
    if (rates != null) {
      _rates = [];
      _r = 0;
      for (_i = 0, _len = rates.length; _i < _len; _i++) {
        r = rates[_i];
        _rates.push(_r += r);
      }
      rd = _.random(0, maxVal);
      for (i = _j = 0, _len1 = _rates.length; _j < _len1; i = ++_j) {
        r = _rates[i];
        if (rd <= r) {
          return values[i];
        }
      }
    } else if (values.length > 0) {
      return values[_.random(0, values.length - 1)];
    } else {
      return values[0];
    }
  },
  parseEffect: function(value) {
    var base_val, lv_grow, pattern, _ref;
    pattern = /^\d+,\d+$/;
    if (!pattern.exec(value)) {
      throw new Error("effect value " + value + " is invalid");
    }
    _ref = value.split(','), base_val = _ref[0], lv_grow = _ref[1];
    return [parseInt(base_val), parseInt(lv_grow)];
  },
  "extends": function(child, parent) {
    var ctor, key;
    for (key in parent) {
      if (parent.hasOwnProperty(key)) {
        child[key] = parent[key];
      }
    }
    ctor = function() {
      this.constructor = child;
    };
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  },
  deepCopy: function(obj) {
    var item, key, newArr, newObj, _i, _len, _ref;
    newObj = {};
    for (key in obj) {
      if (_.isObject(obj[key]) && !_.isArray(obj[key])) {
        newObj[key] = Utility.deepCopy(obj[key]);
      } else if (_.isArray(obj[key])) {
        newArr = [];
        _ref = obj[key];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (_.isObject(item)) {
            newArr.push(Utility.deepCopy(item));
          } else {
            newArr.push(item);
          }
        }
        newObj[key] = newArr;
      } else {
        newObj[key] = obj[key];
      }
    }
    return newObj;
  },
  hasMark: function(val, bit) {
    return val >> (bit - 1) & 1;
  },
  mark: function(val, bit) {
    return val = val | (1 << (bit - 1));
  },
  walk: function(dir, done) {
    var results;
    results = [];
    return fs.readdir(dir, function(err, list) {
      var pending;
      if (err) {
        return done(err);
      }
      pending = list.length;
      if (!pending) {
        return done(null, results);
      }
      return list.forEach(function(file) {
        file = dir + '/' + file;
        return fs.stat(file, function(err, stat) {
          if (stat && stat.isDirectory()) {
            return Utility.walk(file, function(err, res) {
              results = results.concat(res);
              if (!--pending) {
                return done(null, results);
              }
            });
          } else {
            results.push(file);
            if (!--pending) {
              return done(null, results);
            }
          }
        });
      });
    });
  },
  walkSync: function(dir) {
    var file, item, list, res, results, stat, _i, _len;
    results = [];
    list = fs.readdirSync(dir);
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      item = list[_i];
      file = "" + dir + "/" + item;
      stat = fs.statSync(file);
      if (stat && stat.isDirectory()) {
        res = Utility.walkSync(file);
        results = results.concat(res);
      } else {
        results.push(file);
      }
    }
    return results;
  }
};

module.exports = Utility;

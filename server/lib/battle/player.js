// Generated by CoffeeScript 1.6.2
var Hero, Matrix, Module, Player, exports, log, tab, utility, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Module = require('../common/module');

Hero = require('./hero');

Matrix = require('./matrix');

tab = require('../manager/table');

_ = require('underscore');

utility = require('../common/utility');

log = require('../common/logger');

Player = (function(_super) {
  __extends(Player, _super);

  Player.table = 'player';

  function Player(entity) {
    var key, val, _ref;

    if (entity != null) {
      _ref = entity.getAttributes();
      for (key in _ref) {
        val = _ref[key];
        this[key] = val;
      }
    }
    if (!entity) {
      this.initAttrs();
    }
    this.heros = [];
    this.lineUp = '';
    this.enemy = null;
    this.is_attacker = false;
    this.matrix = new Matrix();
    this.loadHeros();
    this.bindCards();
    this.setAttackCount();
    Player.__super__.constructor.apply(this, arguments);
  }

  Player.prototype.initAttrs = function() {
    this.id = 0;
    this.lv = 0;
    this.exp = 0;
    this.power = 0;
    this.money = 0;
    return this.hero_ids = [];
  };

  Player.prototype.setEnemy = function(enm, is_attacker) {
    var _this = this;

    if (is_attacker == null) {
      is_attacker = false;
    }
    this.enemy = enm;
    this.is_attacker = is_attacker;
    return this.heros.forEach(function(h) {
      return h.setIdx(_this.matrix.positionToNumber(h.pos), is_attacker);
    });
  };

  Player.prototype.loadHeros = function() {
    var id;

    return this.heros = this.hero_ids != null ? (function() {
      var _i, _len, _ref, _results;

      _ref = this.hero_ids;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        _results.push(new Hero(id, this));
      }
      return _results;
    }).call(this) : [];
  };

  Player.prototype.bindCards = function() {
    var _this = this;

    if ((this.lineUp != null) && this.lineUp !== '') {
      this.parseLineUp().forEach(function(item) {
        var card_id, pos, _h, _hero;

        pos = item[0], card_id = item[1];
        _hero = function(id) {
          var h, _i, _len, _ref;

          _ref = _this.heros;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            h = _ref[_i];
            if (h.card_id === parseInt(id)) {
              return h;
            }
          }
          return null;
        };
        _h = _hero(card_id);
        if (_h) {
          return _this.matrix.set(pos, _h);
        } else {
          return console.log('you have not such card with id is ' + card_id);
        }
      });
    }
    return this.matrix.reset();
  };

  Player.prototype.parseLineUp = function(lineUp) {
    var pos_hero, _str;

    _str = lineUp || this.lineUp;
    pos_hero = _str.split(',');
    return pos_hero.map(function(item) {
      return item.split(':');
    });
  };

  Player.prototype.setLineUp = function(lineUp) {
    this.lineUp = lineUp;
    this.bindCards();
    return this;
  };

  Player.prototype.cards = function() {
    return _.map(this.matrix.allWithNull(), function(c) {
      if (c != null) {
        return {
          id: c.id,
          lv: c.lv,
          hp: c.init_hp,
          atk: c.init_atk
        };
      } else {
        return null;
      }
    });
  };

  Player.prototype.death = function() {
    var res;

    res = this.heros.filter(function(hero) {
      return hero.hp > 0;
    });
    return res.length === 0;
  };

  Player.prototype.attack = function(callback) {
    var _hero;

    _hero = this.currentHero();
    if (_hero === null || _hero.death()) {
      return log.warn("玩家 " + this.name + " 拿不到当前卡牌，或者没有可用的牌可出了。卡牌：" + (_hero != null ? _hero.name : void 0) + ", 死亡状态：" + (_hero != null ? _hero.death() : void 0));
    } else {
      log.info("" + this.name + " 出手", _hero.name);
      return _hero.attack(callback);
    }
  };

  Player.prototype.currentHero = function() {
    return this.matrix.current();
  };

  Player.prototype.nextHero = function() {
    var res;

    res = this.matrix.next();
    return res;
  };

  Player.prototype.currentIndex = function() {
    return this.matrix.curIndex;
  };

  Player.prototype.herosToBeAttacked = function(scope, args) {
    return this.matrix.attackElement(scope, args);
  };

  Player.prototype.reset = function() {
    this.matrix.reset();
    this.setAttackCount();
    return this.heros.forEach(function(h) {
      return h.reset();
    });
  };

  /*
  检查在一个回合中，还有没有出手次数
  */


  Player.prototype.bulletOut = function() {
    var res;

    res = _.find(this.heros, function(h) {
      return !h.isAttacked();
    });
    return !res;
  };

  Player.prototype.aliveHeros = function() {
    var res;

    res = this.heros.filter(function(h) {
      return (h.hp != null) && h.hp > 0;
    });
    return res || [];
  };

  Player.prototype.setAttackCount = function() {
    return this.attack_count = this.aliveHeros().length;
  };

  return Player;

})(Module);

exports = module.exports = Player;

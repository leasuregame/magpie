// Generated by CoffeeScript 1.6.2
var Module, Skill, defautls, exports, log, utility, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Module = require('../common/module');

utility = require('../common/utility');

_ = require('underscore');

log = require('../common/logger');

defautls = {
  id: 0,
  name: 'nobody',
  type: 'single_fight',
  scope: 'default',
  random_num: 1,
  star3: '',
  rate3: '',
  star4: '',
  rate4: '',
  star5: '',
  rate5: ''
};

Skill = (function(_super) {
  __extends(Skill, _super);

  function Skill() {
    _ref = Skill.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Skill.prototype.init = function(hero, attrs) {
    var key, value, _ref1, _results;

    this.hero = hero;
    this.lv = hero.skill_lv;
    this._attrs = attrs || defautls;
    _ref1 = this._attrs;
    _results = [];
    for (key in _ref1) {
      value = _ref1[key];
      _results.push(this[key] = value);
    }
    return _results;
  };

  Skill.prototype.getTargets = function() {
    var arg, _ref1;

    switch (this.scope) {
      case 'default':
        arg = this.hero.pos;
        break;
      case 'random':
        arg = this.random_num;
        break;
      case 'lengthways':
        arg = this.hero.pos;
        break;
      default:
        arg = null;
    }
    return (_ref1 = this._player()) != null ? _ref1.herosToBeAttacked(this.scope, arg) : void 0;
  };

  Skill.prototype.getRate = function() {
    var base_val, lv_grow, _ref1;

    _ref1 = utility.parseEffect(this['rate' + this.hero.star]), base_val = _ref1[0], lv_grow = _ref1[1];
    return base_val + lv_grow * (this.lv - 1);
  };

  Skill.prototype.effectValue = function() {
    var base_val, lv_grow, _ref1;

    _ref1 = utility.parseEffect(this['star' + this.hero.star]), base_val = _ref1[0], lv_grow = _ref1[1];
    return (base_val + lv_grow * (this.lv - 1)) / 100;
  };

  Skill.prototype.get_round_num = function() {
    var _ref1;

    return (_ref1 = this._player()) != null ? _ref1.round_num : void 0;
  };

  Skill.prototype.check = function(tags) {
    var _ref1;

    if ((_ref1 = this.type) === 'aoe' || _ref1 === 'mult_heal') {
      log.warn(this.type, this.scope);
      log.warn(_.isArray(tags) && tags.length > 1);
      log.warn(this._satisfy(tags));
    }
    return utility.hitRate(this.getRate()) && this._satisfy(tags);
  };

  Skill.prototype._satisfy = function(tags) {
    var _ref1;

    if ((_ref1 = this.type) === 'aoe' || _ref1 === 'mult_heal') {
      if (_.isArray(tags) && tags.length > 1) {
        return true;
      } else {
        return false;
      }
    }
    return true;
  };

  Skill.prototype._player = function() {
    var _ref1, _ref2;

    if ((_ref1 = this.type) === 'single_heal' || _ref1 === 'mult_heal') {
      return this.hero.player;
    }
    if ((_ref2 = this.type) === 'single_fight' || _ref2 === 'aoe') {
      return this.hero.player.enemy;
    }
    throw new Error("Skill: can't get target with type: '" + this.type + "' ");
  };

  return Skill;

})(Module);

exports = module.exports = Skill;

// Generated by CoffeeScript 1.6.2
var Application, EventEmitter, STATE_INITED, STATE_START, STATE_STARTED, STATE_STOPED, contains, logger, removeServer, replaceServer,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

EventEmitter = require('events').EventEmitter;

logger = require('../common/logger').getLogger('application');

/*
  Application states
*/


STATE_INITED = 1;

STATE_START = 2;

STATE_STARTED = 3;

STATE_STOPED = 4;

Application = (function() {
  function Application(opts) {
    opts = opts || {};
    this.loaded = [];
    this.components = {};
    this.settings = {};
    this.set('base', opts.base);
    this.event = new EventEmitter();
    this.serverId = null;
    this.serverType = null;
    this.curServer = null;
    this.servers = {};
    this.serverTypeMaps = {};
    this.serverTypes = [];
    this.state = STATE_INITED;
    logger.info('application inited: %j', this.getServerId());
  }

  Application.prototype.getBase = function() {
    return this.get('base') || process.cwd();
  };

  Application.prototype.load = function(name, component, opts) {
    if (typeof name !== 'string') {
      opts = component;
      component = name;
      name = null;
      if (typeof component.name === 'string') {
        name = component.name;
      }
    }
    if (typeof component === 'function') {
      component = component(this, opts);
    }
    if (!name && component.name === 'string') {
      name = component.name;
    }
    if (name && this.components[name]) {
      logger.warn('ignore duplicate component: %j', name);
      return;
    }
    this.loaded.push(component);
    if (name) {
      this.components[name] = component;
    }
    return this;
  };

  Application.prototype.loadConfig = function(key, val) {
    var env;

    env = this.get('env');
    val = require(val);
    if (val[env]) {
      val = val[env];
    }
    return this.set(key, val);
  };

  Application.prototype.route = function(serverType, routeFunc) {
    var routes;

    routes = this.get('__routes__');
    if (!routes) {
      routes = {};
      this.set('__routes__', routes);
    }
    routes[serverType] = routeFunc;
    return this;
  };

  Application.prototype.start = function(cb) {
    var _this = this;

    if (this.state > STATE_INITED) {
      cb(new Error('application has already start.'));
      return;
    }
    loadDefaultComponents(this);
    processComponents(this.loaded, 'start', function(err) {
      _this.state = STATE_START;
      if (err) {
        return cb(err);
      } else {
        return logger.info('%j start');
      }
    });
    return {
      stop: function(force) {
        if (this.state > STATE_STARTED) {
          logger.warn('Applicaiton is not running now.');
          return;
        }
        this.state = STATE_STOPED;
        return stopComps(this.loaded, 0, force, function() {
          if (force) {
            return process.exit(0);
          }
        });
      },
      set: function(setting, val, attach) {
        if (arguments.length === 1) {
          return this.settings[setting];
        }
        this.settings[setting] = val;
        if (attach) {
          this[setting] = val;
        }
        return this;
      },
      get: function(setting) {
        return this.settings[setting];
      },
      enabled: function(setting) {
        return !!this.get(setting);
      },
      disabled: function(setting) {
        return !this.get(setting);
      },
      enable: function(setting) {
        return this.set(setting, true);
      },
      disable: function(setting) {
        return this.set(setting, false);
      },
      /*
       * Configure callback for the specified env and server type.
       * When no env is specified that callback will
       * be invoked for all environments and when no type is specified
       * that callback will be invoked for all server types.
       *
       * Examples:
       *
       *  app.configure(function(){
       *    // executed for all envs and server types
       *  });
       *
       *  app.configure('development', function(){
       *    // executed development env
       *  });
       *
       *  app.configure('development', 'connector', function(){
       *    // executed for development env and connector server type
       *  });
       *
       * @param {String} env application environment
       * @param {Function} fn callback function
       * @param {String} type server type
       * @return {Application} for chaining
       * @memberOf Application
      */

      configure: function(env, type, fn) {
        var args;

        args = [].slice.call(arguments);
        fn = args.pop();
        env = 'all';
        type = 'all';
        if (args.length > 0) {
          env = args[0];
        }
        if (args.length > 1) {
          type = args[1];
        }
        if (env === 'all' || contains(this.settings.env, env)) {
          if (type === 'all' || contains(this.settings.serverType, type)) {
            fn.call(this);
          }
        }
        return this;
      },
      getCurServer: function() {
        return this.curServer;
      },
      getServerId: function() {
        return this.serverId;
      },
      getServerType: function() {
        return this.serverType;
      },
      getServers: function() {
        return this.servers;
      },
      getServersFromConfig: function() {
        return this.get('__serverMap__');
      },
      getServerTypes: function() {
        return this.serverTypes;
      },
      getServerById: function(serverId) {
        return this.servers[serverId];
      },
      getServerFromConfig: function(serverId) {
        return this.get('__serverMap__')[serverId];
      },
      getServersByType: function(serverType) {
        return this.serverTypeMaps[serverType];
      },
      addServers: function(servers) {
        var item, slist, _i, _len, _ref;

        if (!servers || !servers.length) {
          return;
        }
        for (_i = 0, _len = servers.length; _i < _len; _i++) {
          item = servers[_i];
          this.servers[item.id] = item;
          slist = this.serverTypeMaps[item.serverType];
          if (!slist) {
            this.serverTypeMaps[item.serverType] = slist = [];
          }
          replaceServer(slist, item);
          if (_ref = item.serverType, __indexOf.call(this.serverTypes, _ref) < 0) {
            this.serverTypes.push(item.serverType);
          }
        }
        return this.event.emit('add_servers', servers);
      },
      removeServer: function(ids) {
        var id, item, slist, _i, _len;

        if (!ids || !ids.length) {
          return;
        }
        for (_i = 0, _len = ids.length; _i < _len; _i++) {
          id = ids[_i];
          item = this.servers[id];
          if (!item) {
            continue;
          }
          delete this.servers[id];
          slist = this.serverTypeMaps[item.serverType];
          removeServer(slist, id);
        }
        return this.event.emit('remove_servers', ids);
      }
    };
  };

  return Application;

})();

replaceServer = function(slist, serverInfo) {
  var item, _i, _len;

  for (_i = 0, _len = slist.length; _i < _len; _i++) {
    item = slist[_i];
    if (item.id === serverInfo.id) {
      item = serverInfo;
      return;
    }
  }
  return slist.push(serverInfo);
};

removeServer = function(slist, id) {
  var i, l, _i;

  if (!slist || !slist.length) {
    return;
  }
  l = slist.length;
  for (i = _i = 0; 0 <= l ? _i < l : _i > l; i = 0 <= l ? ++_i : --_i) {
    if (slist[i].id === id) {
      slist.splice(i, 1);
      return;
    }
  }
};

contains = function(str, settings) {
  var item, ts, _i, _len;

  if (!settings) {
    return false;
  }
  ts = settings.split('|');
  for (_i = 0, _len = ts.length; _i < _len; _i++) {
    item = ts[_i];
    if (str === item) {
      return true;
    }
  }
  return false;
};

module.exports = Application;
